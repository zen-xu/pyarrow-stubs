import socket
from typing import (
    Any,
    overload,
)

import pyarrow.lib
from typing_extensions import (
    Literal,
    TypedDict,
)

PLASMA_WAIT_TIMEOUT: int

class _ListResult(TypedDict):
    data_size: int
    metadata_size: int
    ref_count: int
    create_time: float
    construct_duration: int
    state: Literal["created", "sealed"]

class ArrowException(Exception): ...

class ObjectID(pyarrow.lib._Weakrefable):
    def __init__(self, object_id: bytes) -> None: ...
    def binary(self) -> bytes: ...
    @staticmethod
    def from_random() -> ObjectID: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class ObjectNotAvailable(pyarrow.lib._Weakrefable): ...
class PlasmaBuffer(pyarrow.lib.Buffer): ...

class PlasmaClient(pyarrow.lib._Weakrefable):
    store_socket_name: str
    def __init__(self) -> None: ...
    def _release(self, object_id: ObjectID) -> None: ...
    def contains(self, object_id: ObjectID) -> bool: ...
    def create(
        self, object_id: ObjectID, data_size: int, metadata: bytes = ...
    ) -> pyarrow.lib.Buffer: ...
    def create_and_seal(
        self, object_id: ObjectID, data: bytes, metadata: bytes = ...
    ) -> None: ...
    def debug_string(self) -> str: ...
    def decode_notifications(
        self, buf: pyarrow.lib.Buffer
    ) -> tuple[list[ObjectID], int, int]: ...
    def delete(self, object_ids: list[ObjectID]) -> None: ...
    def disconnect(self) -> None: ...
    def evict(self, num_bytes: int) -> None: ...
    @overload
    def get(
        self,
        object_ids: ObjectID,
        timeout_ms: int = ...,
        serialization_context: pyarrow.lib.SerializationContext = ...,
    ) -> Any: ...
    @overload
    def get(
        self,
        object_ids: list[ObjectID],
        timeout_ms: int = ...,
        serialization_context: pyarrow.lib.SerializationContext = ...,
    ) -> list[Any]: ...
    def get_buffers(
        self,
        object_ids: list[ObjectID],
        timeout_ms: int = ...,
        with_meta: bool = ...,
    ) -> list[PlasmaBuffer | None | tuple[PlasmaBuffer | None, bytes]]: ...
    def get_metadata(
        self, object_ids: list[ObjectID], timeout_ms: int = ...
    ) -> list[PlasmaBuffer | None]: ...
    def get_next_notification(self) -> list[tuple[ObjectID, int, int]]: ...
    def get_notification_socket(self) -> socket.socket: ...
    def hash(self, object_id: ObjectID) -> bytes: ...
    def list(self) -> _ListResult: ...
    def put(
        self,
        value: Any,
        object_id: ObjectID | None = ...,
        memcopy_threads: int = ...,
        serialization_context: pyarrow.lib.SerializationContext = ...,
    ) -> ObjectID: ...
    def put_raw_buffer(
        self,
        value: memoryview,
        object_id: ObjectID | None = ...,
        metadata: bytes = ...,
        memcopy_threads: int = ...,
    ) -> ObjectID: ...
    def seal(self, object_id: ObjectID) -> None: ...
    def set_client_options(
        self, client_name: str, limit_output_memory: int
    ) -> None: ...
    def store_capacity(self) -> int: ...
    def subscribe(self) -> None: ...
    def to_capsule(self) -> Any: ...

class PlasmaObjectExists(pyarrow.lib.ArrowException): ...
class PlasmaObjectNotFound(pyarrow.lib.ArrowException): ...
class PlasmaStoreFull(pyarrow.lib.ArrowException): ...

def connect(store_socket_name: str, num_retries: int = ...) -> PlasmaClient: ...
def get_socket_from_fd(
    fileno: int | None,
    family: socket.AddressFamily | int,
    type: socket.SocketKind | int,
) -> socket.socket: ...
def make_object_id(object_id: bytes) -> ObjectID: ...
