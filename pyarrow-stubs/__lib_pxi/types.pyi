from collections.abc import Mapping
from typing import Any, Generic, Iterator, Literal, Self, TypeAlias, overload

import numpy as np

from pyarrow.lib import Array, ChunkedArray, ExtensionArray, _Metadata, _Weakrefable
from typing_extensions import TypeVar

from .scalar import ExtensionScalar

CSchema: TypeAlias = Any

class DataType(_Weakrefable):
    def field(self, i: int) -> Field: ...
    @property
    def id(self) -> int: ...
    @property
    def bit_width(self) -> int: ...
    @property
    def byte_width(self) -> int: ...
    @property
    def num_fields(self) -> int: ...
    @property
    def num_buffers(self) -> int: ...
    def __hash__(self) -> int: ...
    def equals(self, other: DataType | str, *, check_metadata: bool = False) -> bool: ...
    def to_pandas_dtype(self) -> np.generic: ...
    def _export_to_c(self, out_ptr: int) -> None: ...
    @classmethod
    def _import_from_c(cls, in_ptr: int) -> Self: ...
    def __arrow_c_schema__(self) -> CSchema: ...
    @classmethod
    def _import_from_c_capsule(cls, schema: CSchema) -> Self: ...

class DictionaryMemo(_Weakrefable): ...

_I = TypeVar("_I", bound=DataType)
_V = TypeVar("_V", bound=DataType)
_Ordered = TypeVar("_Ordered", bound=Literal[True, False], default=Literal[False])

class DictionaryType(DataType, Generic[_I, _V, _Ordered]):
    @property
    def ordered(self) -> _Ordered: ...
    @property
    def index_type(self) -> _I: ...
    @property
    def value_type(self) -> _V: ...

class ListType(DataType, Generic[_V]):
    @property
    def value_field(self) -> Field: ...
    @property
    def value_type(self) -> _V: ...

class LargeListType(DataType, Generic[_V]):
    @property
    def value_field(self) -> Field: ...
    @property
    def value_type(self) -> _V: ...

class ListViewType(DataType, Generic[_V]):
    @property
    def value_field(self) -> Field: ...
    @property
    def value_type(self) -> _V: ...

class LargeListViewType(DataType, Generic[_V]):
    @property
    def value_field(self) -> Field: ...
    @property
    def value_type(self) -> _V: ...

_K = TypeVar("_K", bound=DataType)

class MapType(DataType, Generic[_K, _V, _Ordered]):
    @property
    def key_field(self) -> Field: ...
    @property
    def key_type(self) -> _K: ...
    @property
    def item_field(self) -> Field: ...
    @property
    def item_type(self) -> _V: ...
    @property
    def keys_sorted(self) -> _Ordered: ...

_Size = TypeVar("_Size")

class FixedSizeListType(DataType, Generic[_V, _Size]):
    @property
    def value_field(self) -> Field: ...
    @property
    def value_type(self) -> _V: ...
    @property
    def list_size(self) -> _Size: ...

class StructType(DataType):
    def get_field_index(self, name: str) -> int: ...
    def field(self, i: int | str) -> Field: ...
    def get_all_field_indices(self, name: str) -> list[int]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Field]: ...
    __getitem__ = field

class UnionType(DataType):
    @property
    def mode(self) -> str: ...
    @property
    def type_codes(self) -> list[int]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Field]: ...
    def field(self, i: int) -> Field: ...
    __getitem__ = field

class SparseUnionType(UnionType):
    @property
    def mode(self) -> Literal["sparse"]: ...

class DenseUnionType(UnionType):
    @property
    def mode(self) -> Literal["dense"]: ...

_Unit = TypeVar("_Unit", bound=Literal["s", "ms", "us", "ns"])
_Tz = TypeVar("_Tz", str, None)

class TimestampType(DataType, Generic[_Unit, _Tz]):
    @property
    def unit(self) -> _Unit: ...
    @property
    def tz(self) -> _Tz: ...

_Time32Unit = TypeVar("_Time32Unit", bound=Literal["s", "ms"])

class Time32Type(DataType, Generic[_Time32Unit]):
    @property
    def unit(self) -> _Time32Unit: ...

_Time64Unit = TypeVar("_Time64Unit", bound=Literal["us", "ns"])

class Time64Type(DataType, Generic[_Time64Unit]):
    @property
    def unit(self) -> _Time64Unit: ...

class DurationType(DataType, Generic[_Unit]):
    @property
    def unit(self) -> _Unit: ...

class FixedSizeBinaryType(DataType): ...

_Precision = TypeVar("_Precision")
_Scale = TypeVar("_Scale")

class Decimal128Type(FixedSizeBinaryType, Generic[_Precision, _Scale]):
    @property
    def precision(self) -> _Precision: ...
    @property
    def scale(self) -> _Scale: ...

class Decimal256Type(FixedSizeBinaryType, Generic[_Precision, _Scale]):
    @property
    def precision(self) -> _Precision: ...
    @property
    def scale(self) -> _Scale: ...

_RunEndType = TypeVar("_RunEndType", bound=DataType)

class RunEndEncodedType(DataType, Generic[_RunEndType, _V]):
    @property
    def run_end_type(self) -> _RunEndType: ...
    @property
    def value_type(self) -> _V: ...

_StorageType = TypeVar("_StorageType", bound=DataType)

class BaseExtensionType(DataType, Generic[_StorageType]):
    def __arrow_ext_class__(self) -> type[ExtensionArray]: ...
    def __arrow_ext_scalar_class__(self) -> type[ExtensionScalar]: ...
    @property
    def extension_name(self) -> str: ...
    @property
    def storage_type(self) -> _StorageType: ...
    @overload
    def wrap_array(self, storage: Array) -> Array: ...
    @overload
    def wrap_array(self, storage: ChunkedArray) -> ChunkedArray: ...

class ExtensionType(BaseExtensionType[_StorageType]):
    def __init__(self, storage_type: _StorageType, extension_name: str) -> None: ...
    def __arrow_ext_serialize__(self) -> bytes: ...
    @classmethod
    def __arrow_ext_deserialize__(cls, storage_type: _StorageType, serialized: bytes) -> Self: ...

class FixedShapeTensorType(BaseExtensionType, Generic[_StorageType, _V]):
    @property
    def value_type(self) -> _V: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def dim_names(self) -> list[str] | None: ...
    @property
    def permutation(self) -> list[int] | None: ...

class PyExtensionType(ExtensionType[_StorageType]):
    def __init__(self, storage_type: _StorageType) -> None: ...
    @classmethod
    def set_auto_load(cls, value: bool) -> None: ...

class UnknownExtensionType(PyExtensionType[_StorageType]):
    def __init__(self, storage_type: _StorageType, serialized: bytes) -> None: ...

def register_extension_type(ext_type: PyExtensionType) -> None: ...
def unregister_extension_type(type_name: str) -> None: ...

class KeyValueMetadata(_Metadata, Mapping[bytes, bytes]):
    def __init__(self, __arg0__: Mapping[bytes, bytes] | None = None, **kwargs) -> None: ...
    def equals(self, other: KeyValueMetadata) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, __key: object) -> bool: ...
    def __getitem__(self, __key: Any) -> Any: ...
    def __iter__(self) -> Iterator[bytes]: ...
    def get_all(self, key: str) -> list[bytes]: ...
    def to_dict(self) -> dict[bytes, bytes]: ...

def ensure_metadata(
    meta: Mapping[bytes | str, bytes | str] | KeyValueMetadata | None, allow_none: bool = False
) -> KeyValueMetadata | None: ...

_DataTypeT = TypeVar("_DataTypeT", bound=DataType)
_NewDataTypeT = TypeVar("_NewDataTypeT", bound=DataType)
_Nullable = TypeVar("_Nullable", bound=Literal[True, False], default=Literal[True])

class Field(_Weakrefable, Generic[_DataTypeT, _Nullable]):
    def equals(self, other: Field, check_metadata: bool = False) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def nullable(self) -> _Nullable: ...
    @property
    def name(self) -> str: ...
    @property
    def metadata(self) -> dict[bytes, bytes] | None: ...
    def with_metadata(self, metadata: dict[bytes | str, bytes | str]) -> Self: ...
    def remove_metadata(self) -> None: ...
    def with_type(self, new_type: _NewDataTypeT) -> Field[_NewDataTypeT]: ...
    def with_name(self, name: str) -> Self: ...
    def with_nullable(self, nullable: _Nullable) -> Field[_DataTypeT, _Nullable]: ...
