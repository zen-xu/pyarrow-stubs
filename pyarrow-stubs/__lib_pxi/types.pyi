import datetime as dt

from collections.abc import Mapping
from decimal import Decimal
from typing import Any, Generic, Iterable, Iterator, Literal, Protocol, Self, TypeAlias, overload

import numpy as np
import pandas as pd

from pyarrow.lib import (
    Array,
    ChunkedArray,
    ExtensionArray,
    MemoryPool,
    MonthDayNano,
    Table,
    _Metadata,
    _Weakrefable,
)
from typing_extensions import TypeVar

from .scalar import ExtensionScalar

CSchema: TypeAlias = Any

class DataType(_Weakrefable):
    def field(self, i: int) -> Field: ...
    @property
    def id(self) -> int: ...
    @property
    def bit_width(self) -> int: ...
    @property
    def byte_width(self) -> int: ...
    @property
    def num_fields(self) -> int: ...
    @property
    def num_buffers(self) -> int: ...
    def __hash__(self) -> int: ...
    def equals(self, other: DataType | str, *, check_metadata: bool = False) -> bool: ...
    def to_pandas_dtype(self) -> np.generic: ...
    def _export_to_c(self, out_ptr: int) -> None: ...
    @classmethod
    def _import_from_c(cls, in_ptr: int) -> Self: ...
    def __arrow_c_schema__(self) -> CSchema: ...
    @classmethod
    def _import_from_c_capsule(cls, schema: CSchema) -> Self: ...

# =========================== Scalar Data Types ===========================
_AsPyType = TypeVar("_AsPyType")

class ScalarDataType(DataType, Generic[_AsPyType]): ...
class NullType(ScalarDataType[None]): ...
class BoolType(ScalarDataType[bool]): ...
class Uint8Type(ScalarDataType[int]): ...
class Int8Type(ScalarDataType[int]): ...
class Uint16Type(ScalarDataType[int]): ...
class Int16Type(ScalarDataType[int]): ...
class Uint32Type(ScalarDataType[int]): ...
class Int32Type(ScalarDataType[int]): ...
class Uint64Type(ScalarDataType[int]): ...
class Int64Type(ScalarDataType[int]): ...
class Float16Type(ScalarDataType[float]): ...
class Float32Type(ScalarDataType[float]): ...
class Float64Type(ScalarDataType[float]): ...
class Date32Type(ScalarDataType[dt.date]): ...
class Date64Type(ScalarDataType[dt.date]): ...
class MonthDayNanoIntervalType(ScalarDataType[MonthDayNano]): ...
class StringType(ScalarDataType[str]): ...
class LargeStringType(ScalarDataType[str]): ...
class StringViewType(ScalarDataType[str]): ...
class BinaryType(ScalarDataType[bytes]): ...
class LargeBinaryType(ScalarDataType[bytes]): ...
class BinaryViewType(ScalarDataType[bytes]): ...

_Unit = TypeVar("_Unit", bound=Literal["s", "ms", "us", "ns"])
_Tz = TypeVar("_Tz", str, None)

class TimestampType(ScalarDataType[int], Generic[_Unit, _Tz]):
    @property
    def unit(self) -> _Unit: ...
    @property
    def tz(self) -> _Tz: ...

_Time32Unit = TypeVar("_Time32Unit", bound=Literal["s", "ms"])

class Time32Type(ScalarDataType[dt.time], Generic[_Time32Unit]):
    @property
    def unit(self) -> _Time32Unit: ...

_Time64Unit = TypeVar("_Time64Unit", bound=Literal["us", "ns"])

class Time64Type(ScalarDataType[dt.time], Generic[_Time64Unit]):
    @property
    def unit(self) -> _Time64Unit: ...

class DurationType(ScalarDataType[dt.timedelta], Generic[_Unit]):
    @property
    def unit(self) -> _Unit: ...

class FixedSizeBinaryType(ScalarDataType[Decimal]): ...

_Precision = TypeVar("_Precision")
_Scale = TypeVar("_Scale")

class Decimal128Type(FixedSizeBinaryType, Generic[_Precision, _Scale]):
    @property
    def precision(self) -> _Precision: ...
    @property
    def scale(self) -> _Scale: ...

class Decimal256Type(FixedSizeBinaryType, Generic[_Precision, _Scale]):
    @property
    def precision(self) -> _Precision: ...
    @property
    def scale(self) -> _Scale: ...

# =========================== Collection Data Types ===========================
_DataTypeT = TypeVar("_DataTypeT", bound=DataType)

class ListType(DataType, Generic[_DataTypeT]):
    @property
    def value_field(self) -> Field[_DataTypeT]: ...
    @property
    def value_type(self) -> _DataTypeT: ...

class LargeListType(ListType[_DataTypeT]): ...
class ListViewType(ListType[_DataTypeT]): ...
class LargeListViewType(ListType[_DataTypeT]): ...

class FixedSizeListType(ListType[_DataTypeT], Generic[_DataTypeT, _Size]):
    @property
    def list_size(self) -> _Size: ...

class DictionaryMemo(_Weakrefable): ...

_IndexT = TypeVar("_IndexT", bound=ScalarDataType)
_ValueT = TypeVar("_ValueT", bound=ScalarDataType)
_Ordered = TypeVar("_Ordered", bound=Literal[True, False], default=Literal[False])

class DictionaryType(DataType, Generic[_IndexT, _ValueT, _Ordered]):
    @property
    def ordered(self) -> _Ordered: ...
    @property
    def index_type(self) -> _IndexT: ...
    @property
    def value_type(self) -> _ValueT: ...

_K = TypeVar("_K", bound=ScalarDataType)

class MapType(DataType, Generic[_K, _ValueT, _Ordered]):
    @property
    def key_field(self) -> Field[_K, Literal[False]]: ...
    @property
    def key_type(self) -> _K: ...
    @property
    def item_field(self) -> Field[_ValueT]: ...
    @property
    def item_type(self) -> _ValueT: ...
    @property
    def keys_sorted(self) -> _Ordered: ...

_Size = TypeVar("_Size")

class StructType(DataType):
    def get_field_index(self, name: str) -> int: ...
    def field(self, i: int | str) -> Field: ...
    def get_all_field_indices(self, name: str) -> list[int]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Field]: ...
    __getitem__ = field

class UnionType(DataType):
    @property
    def mode(self) -> Literal["sparse", "dense"]: ...
    @property
    def type_codes(self) -> list[int]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Field]: ...
    def field(self, i: int) -> Field: ...
    __getitem__ = field

class SparseUnionType(UnionType):
    @property
    def mode(self) -> Literal["sparse"]: ...

class DenseUnionType(UnionType):
    @property
    def mode(self) -> Literal["dense"]: ...

_RunEndType = TypeVar("_RunEndType", Int16Type, Int32Type, Int64Type)

class RunEndEncodedType(DataType, Generic[_RunEndType, _ValueT]):
    @property
    def run_end_type(self) -> _RunEndType: ...
    @property
    def value_type(self) -> _ValueT: ...

# =========================== Extension Data Types ===========================

class BaseExtensionType(DataType):
    def __arrow_ext_class__(self) -> type[ExtensionArray]: ...
    def __arrow_ext_scalar_class__(self) -> type[ExtensionScalar]: ...
    @property
    def extension_name(self) -> str: ...
    @property
    def storage_type(self) -> DataType: ...
    @overload
    def wrap_array(self, storage: Array) -> Array: ...
    @overload
    def wrap_array(self, storage: ChunkedArray) -> ChunkedArray: ...

class ExtensionType(BaseExtensionType):
    def __init__(self, storage_type: DataType, extension_name: str) -> None: ...
    def __arrow_ext_serialize__(self) -> bytes: ...
    @classmethod
    def __arrow_ext_deserialize__(cls, storage_type: DataType, serialized: bytes) -> Self: ...

class FixedShapeTensorType(BaseExtensionType, Generic[_ValueT]):
    @property
    def value_type(self) -> _ValueT: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def dim_names(self) -> list[str] | None: ...
    @property
    def permutation(self) -> list[int] | None: ...

class PyExtensionType(ExtensionType):
    def __init__(self, storage_type: DataType) -> None: ...
    @classmethod
    def set_auto_load(cls, value: bool) -> None: ...

class UnknownExtensionType(PyExtensionType):
    def __init__(self, storage_type: DataType, serialized: bytes) -> None: ...

def register_extension_type(ext_type: PyExtensionType) -> None: ...
def unregister_extension_type(type_name: str) -> None: ...

class KeyValueMetadata(_Metadata, Mapping[bytes, bytes]):
    def __init__(self, __arg0__: Mapping[bytes, bytes] | None = None, **kwargs) -> None: ...
    def equals(self, other: KeyValueMetadata) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, __key: object) -> bool: ...
    def __getitem__(self, __key: Any) -> Any: ...
    def __iter__(self) -> Iterator[bytes]: ...
    def get_all(self, key: str) -> list[bytes]: ...
    def to_dict(self) -> dict[bytes, bytes]: ...

def ensure_metadata(
    meta: Mapping[bytes | str, bytes | str] | KeyValueMetadata | None, allow_none: bool = False
) -> KeyValueMetadata | None: ...

_NewDataTypeT = TypeVar("_NewDataTypeT", bound=DataType)
_Nullable = TypeVar("_Nullable", bound=Literal[True, False], default=Literal[True])

class Field(_Weakrefable, Generic[_DataTypeT, _Nullable]):
    def equals(self, other: Field, check_metadata: bool = False) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def nullable(self) -> _Nullable: ...
    @property
    def name(self) -> str: ...
    @property
    def metadata(self) -> dict[bytes, bytes] | None: ...
    def with_metadata(self, metadata: dict[bytes | str, bytes | str]) -> Self: ...
    def remove_metadata(self) -> None: ...
    def with_type(self, new_type: _NewDataTypeT) -> Field[_NewDataTypeT]: ...
    def with_name(self, name: str) -> Self: ...
    def with_nullable(self, nullable: _Nullable) -> Field[_DataTypeT, _Nullable]: ...
    def flatten(self) -> list[Field]: ...
    def _export_to_c(self, out_ptr: int) -> None: ...
    @classmethod
    def _import_from_c(cls, in_ptr: int) -> Self: ...
    def __arrow_c_schema__(self) -> CSchema: ...
    @classmethod
    def _import_from_c_capsule(cls, schema: CSchema) -> Self: ...

class Schema(_Weakrefable):
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> Field: ...
    _field = __getitem__
    def __iter__(self) -> Iterator[Field]: ...
    def __hash__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    @property
    def pandas_metadata(self) -> dict: ...
    @property
    def names(self) -> list[str]: ...
    @property
    def types(self) -> list[DataType]: ...
    @property
    def metadata(self) -> dict[bytes, bytes]: ...
    def empty_table(self) -> Table: ...
    def equals(self, other: Schema, check_metadata: bool = False) -> bool: ...
    @classmethod
    def from_pandas(cls, df: pd.DataFrame, preserve_index: bool | None = None) -> Schema: ...
    def field(self, i: str | bytes) -> Field: ...
    def field_by_name(self, name: str) -> Field: ...
    def get_field_index(self, name: str) -> int: ...
    def get_all_field_indices(self, name: str) -> list[int]: ...
    def append(self, field: Field) -> Schema: ...
    def insert(self, i: int, field: Field) -> Schema: ...
    def remove(self, i: int) -> Schema: ...
    def set(self, i: int, field: Field) -> Schema: ...
    def add_metadata(self, metadata: dict) -> Schema: ...
    def with_metadata(self, metadata: dict) -> Schema: ...
    def serialize(self, memory_pool: MemoryPool | None = None): ...
    def remove_metadata(self) -> Schema: ...
    def to_string(
        self,
        truncate_metadata: bool = True,
        show_field_metadata: bool = True,
        show_schema_metadata: bool = True,
    ) -> str: ...
    def _export_to_c(self, out_ptr: int) -> None: ...
    @classmethod
    def _import_from_c(cls, in_ptr: int) -> Schema: ...
    def __arrow_c_schema__(self) -> CSchema: ...
    @staticmethod
    def _import_from_c_capsule(schema: CSchema) -> Schema: ...

def unify_schemas(
    schemas: list[Schema], *, promote_options: Literal["default", "permissive"] = "default"
) -> Schema: ...

class ArrowCSchema(Protocol):
    def __arrow_c_schema__(self) -> CSchema: ...

@overload
def field(name: ArrowCSchema) -> Field: ...
@overload
def field(
    name: str,
    type: _DataTypeT,
) -> Field[_DataTypeT, Literal[True]]: ...
@overload
def field(
    name: str, type: _DataTypeT, nullable: _Nullable, metadata: dict | None = None
) -> Field[_DataTypeT, _Nullable]: ...
def null() -> NullType: ...
def bool_() -> BoolType: ...
def uint8() -> Uint8Type: ...
def int8() -> Int8Type: ...
def unit16() -> Uint16Type: ...
def int64() -> Int64Type: ...
def uint32() -> Uint32Type: ...
def int32() -> Int32Type: ...
def uint64() -> Uint64Type: ...
def tzinfo_to_string(tz: dt.tzinfo) -> str: ...
def string_to_tzinfo(name: str) -> dt.tzinfo: ...
@overload
def timestamp(unit: _Unit) -> TimestampType[_Unit, None]: ...
@overload
def timestamp(unit: _Unit, tz: _Tz) -> TimestampType[_Unit, _Tz]: ...
def time32(unit: _Time32Unit) -> Time32Type[_Time32Unit]: ...
def time64(unit: _Time64Unit) -> Time64Type[_Time64Unit]: ...
def duration(unit: _Unit) -> DurationType[_Unit]: ...
def month_day_nano_interval() -> MonthDayNanoIntervalType: ...
def date32() -> Date32Type: ...
def date64() -> Date64Type: ...
def float16() -> Float16Type: ...
def float32() -> Float32Type: ...
def float64() -> Float64Type: ...
@overload
def decimal128(precision: _Precision) -> Decimal128Type[_Precision, Literal[0]]: ...
@overload
def decimal128(precision: _Precision, scale: _Scale) -> Decimal128Type[_Precision, _Scale]: ...
@overload
def decimal256(precision: _Precision) -> Decimal256Type[_Precision, Literal[0]]: ...
@overload
def decimal256(precision: _Precision, scale: _Scale) -> Decimal256Type[_Precision, _Scale]: ...
def string() -> StringType: ...

utf8 = string

@overload
def binary() -> BinaryType: ...
@overload
def binary(length: Literal[-1]) -> BinaryType: ...  # type: ignore[overload-overlap]
@overload
def binary(length: int) -> FixedSizeBinaryType: ...
def large_binary() -> LargeBinaryType: ...
def large_string() -> LargeStringType: ...

large_utf8 = large_string

def binary_view() -> BinaryViewType: ...
def string_view() -> StringViewType: ...
@overload
def list_(value_type: Field[_DataTypeT]) -> ListType[_DataTypeT]: ...
@overload
def list_(value_type: _DataTypeT) -> ListType[_DataTypeT]: ...
@overload
def list_(value_type: _DataTypeT, list_size: Literal[-1]) -> ListType[_DataTypeT]: ...  # type: ignore[overload-overlap]
@overload
def list_(value_type: _DataTypeT, list_size: _Size) -> FixedSizeListType[_DataTypeT, _Size]: ...
@overload
def large_list(value_type: Field[_DataTypeT]) -> LargeListType[_DataTypeT]: ...
@overload
def large_list(value_type: _DataTypeT) -> LargeListType[_DataTypeT]: ...
@overload
def list_view(value_type: Field[_DataTypeT]) -> ListViewType[_DataTypeT]: ...
@overload
def list_view(value_type: _DataTypeT) -> ListViewType[_DataTypeT]: ...
@overload
def large_list_view(value_type: Field[_DataTypeT]) -> LargeListViewType[_DataTypeT]: ...
@overload
def large_list_view(value_type: _DataTypeT) -> LargeListViewType[_DataTypeT]: ...
@overload
def map_(key_type: _K, item_type: _IndexT) -> MapType[_K, _IndexT, Literal[False]]: ...
@overload
def map_(
    key_type: _K, item_type: _IndexT, key_sorted: _Ordered
) -> MapType[_K, _IndexT, _Ordered]: ...
def struct(
    fields: Iterable[Field | tuple[str, Field]] | Mapping[str, Field],
) -> StructType: ...
def sparse_union(
    child_fields: list[Field], type_codes: list[int] | None = None
) -> SparseUnionType: ...
def dense_union(
    child_fields: list[Field], type_codes: list[int] | None = None
) -> DenseUnionType: ...
@overload
def union(
    child_fields: list[Field], mode: Literal["sparse"], type_codes: list[int] | None = None
) -> SparseUnionType: ...
@overload
def union(
    child_fields: list[Field], mode: Literal["dense"], type_codes: list[int] | None = None
) -> DenseUnionType: ...
def run_end_encoded(
    run_end_type: _RunEndType, value_type: _ValueT
) -> RunEndEncodedType[_RunEndType, _ValueT]: ...
def fixed_shape_tensor(
    value_type: _ValueT,
    shape: tuple[list[int], ...],
    dim_names: tuple[list[str], ...] | None = None,
    permutation: tuple[list[int], ...] | None = None,
) -> FixedShapeTensorType[_ValueT]: ...
@overload
def type_for_alias(name: Literal["null"]) -> NullType: ...
@overload
def type_for_alias(name: Literal["bool", "boolean"]) -> BoolType: ...
@overload
def type_for_alias(name: Literal["i1", "int8"]) -> Int8Type: ...
@overload
def type_for_alias(name: Literal["i2", "int16"]) -> Int16Type: ...
@overload
def type_for_alias(name: Literal["i4", "int32"]) -> Int32Type: ...
@overload
def type_for_alias(name: Literal["i8", "int64"]) -> Int64Type: ...
@overload
def type_for_alias(name: Literal["u1", "uint8"]) -> Uint8Type: ...
@overload
def type_for_alias(name: Literal["u2", "uint16"]) -> Uint16Type: ...
@overload
def type_for_alias(name: Literal["u4", "uint32"]) -> Uint32Type: ...
@overload
def type_for_alias(name: Literal["u8", "uint64"]) -> Uint64Type: ...
@overload
def type_for_alias(name: Literal["f2", "halffloat", "float16"]) -> Float16Type: ...
@overload
def type_for_alias(name: Literal["f4", "float", "float32"]) -> Float32Type: ...
@overload
def type_for_alias(name: Literal["f8", "double", "float64"]) -> Float64Type: ...
@overload
def type_for_alias(name: Literal["string", "str", "utf8"]) -> StringType: ...
@overload
def type_for_alias(name: Literal["binary"]) -> BinaryType: ...
@overload
def type_for_alias(
    name: Literal["large_string", "large_str", "large_utf8"],
) -> LargeStringType: ...
@overload
def type_for_alias(name: Literal["large_binary"]) -> LargeBinaryType: ...
@overload
def type_for_alias(name: Literal["binary_view"]) -> BinaryViewType: ...
@overload
def type_for_alias(name: Literal["string_view"]) -> StringViewType: ...
@overload
def type_for_alias(name: Literal["date32", "date32[day]"]) -> Date32Type: ...
@overload
def type_for_alias(name: Literal["date64", "date64[ms]"]) -> Date64Type: ...
@overload
def type_for_alias(name: Literal["time32[s]"]) -> Time32Type[Literal["s"]]: ...
@overload
def type_for_alias(name: Literal["time32[ms]"]) -> Time32Type[Literal["ms"]]: ...
@overload
def type_for_alias(name: Literal["time64[us]"]) -> Time64Type[Literal["us"]]: ...
@overload
def type_for_alias(name: Literal["time64[ns]"]) -> Time64Type[Literal["ns"]]: ...
@overload
def type_for_alias(name: Literal["timestamp[s]"]) -> TimestampType[Literal["s"], Any]: ...
@overload
def type_for_alias(name: Literal["timestamp[ms]"]) -> TimestampType[Literal["ms"], Any]: ...
@overload
def type_for_alias(name: Literal["timestamp[us]"]) -> TimestampType[Literal["us"], Any]: ...
@overload
def type_for_alias(name: Literal["timestamp[ns]"]) -> TimestampType[Literal["ns"], Any]: ...
@overload
def type_for_alias(name: Literal["duration[s]"]) -> DurationType[Literal["s"]]: ...
@overload
def type_for_alias(name: Literal["duration[ms]"]) -> DurationType[Literal["ms"]]: ...
@overload
def type_for_alias(name: Literal["duration[us]"]) -> DurationType[Literal["us"]]: ...
@overload
def type_for_alias(name: Literal["duration[ns]"]) -> DurationType[Literal["ns"]]: ...
@overload
def type_for_alias(name: Literal["month_day_nano_interval"]) -> MonthDayNanoIntervalType: ...
@overload
def ensure_type(ty: None, allow_none: Literal[True]) -> None: ...
@overload
def ensure_type(ty: _DataTypeT) -> _DataTypeT: ...
@overload
def ensure_type(ty: Literal["null"]) -> NullType: ...
@overload
def ensure_type(ty: Literal["bool", "boolean"]) -> BoolType: ...
@overload
def ensure_type(ty: Literal["i1", "int8"]) -> Int8Type: ...
@overload
def ensure_type(ty: Literal["i2", "int16"]) -> Int16Type: ...
@overload
def ensure_type(ty: Literal["i4", "int32"]) -> Int32Type: ...
@overload
def ensure_type(ty: Literal["i8", "int64"]) -> Int64Type: ...
@overload
def ensure_type(ty: Literal["u1", "uint8"]) -> Uint8Type: ...
@overload
def ensure_type(ty: Literal["u2", "uint16"]) -> Uint16Type: ...
@overload
def ensure_type(ty: Literal["u4", "uint32"]) -> Uint32Type: ...
@overload
def ensure_type(ty: Literal["u8", "uint64"]) -> Uint64Type: ...
@overload
def ensure_type(ty: Literal["f2", "halffloat", "float16"]) -> Float16Type: ...
@overload
def ensure_type(ty: Literal["f4", "float", "float32"]) -> Float32Type: ...
@overload
def ensure_type(ty: Literal["f8", "double", "float64"]) -> Float64Type: ...
@overload
def ensure_type(ty: Literal["string", "str", "utf8"]) -> StringType: ...
@overload
def ensure_type(ty: Literal["binary"]) -> BinaryType: ...
@overload
def ensure_type(
    ty: Literal["large_string", "large_str", "large_utf8"],
) -> LargeStringType: ...
@overload
def ensure_type(ty: Literal["large_binary"]) -> LargeBinaryType: ...
@overload
def ensure_type(ty: Literal["binary_view"]) -> BinaryViewType: ...
@overload
def ensure_type(ty: Literal["string_view"]) -> StringViewType: ...
@overload
def ensure_type(ty: Literal["date32", "date32[day]"]) -> Date32Type: ...
@overload
def ensure_type(ty: Literal["date64", "date64[ms]"]) -> Date64Type: ...
@overload
def ensure_type(ty: Literal["time32[s]"]) -> Time32Type[Literal["s"]]: ...
@overload
def ensure_type(ty: Literal["time32[ms]"]) -> Time32Type[Literal["ms"]]: ...
@overload
def ensure_type(ty: Literal["time64[us]"]) -> Time64Type[Literal["us"]]: ...
@overload
def ensure_type(ty: Literal["time64[ns]"]) -> Time64Type[Literal["ns"]]: ...
@overload
def ensure_type(ty: Literal["timestamp[s]"]) -> TimestampType[Literal["s"], Any]: ...
@overload
def ensure_type(ty: Literal["timestamp[ms]"]) -> TimestampType[Literal["ms"], Any]: ...
@overload
def ensure_type(ty: Literal["timestamp[us]"]) -> TimestampType[Literal["us"], Any]: ...
@overload
def ensure_type(ty: Literal["timestamp[ns]"]) -> TimestampType[Literal["ns"], Any]: ...
@overload
def ensure_type(ty: Literal["duration[s]"]) -> DurationType[Literal["s"]]: ...
@overload
def ensure_type(ty: Literal["duration[ms]"]) -> DurationType[Literal["ms"]]: ...
@overload
def ensure_type(ty: Literal["duration[us]"]) -> DurationType[Literal["us"]]: ...
@overload
def ensure_type(ty: Literal["duration[ns]"]) -> DurationType[Literal["ns"]]: ...
@overload
def ensure_type(ty: Literal["month_day_nano_interval"]) -> MonthDayNanoIntervalType: ...
def schema(
    fields: Iterable[Field | tuple[str, Field]] | Mapping[str, Field],
    metadata: dict[bytes, bytes] | None = None,
) -> Schema: ...
def from_numpy_dtype(dtype: np.dtype) -> DataType: ...
def is_boolean_value(obj: Any) -> bool: ...
def is_integer_value(obj: Any) -> bool: ...
def is_float_value(obj: Any) -> bool: ...
