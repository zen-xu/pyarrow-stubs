from typing import (
    Any,
    ClassVar,
    overload,
)

import pyarrow.lib

ISO8601: _ISO8601
_stringify_path: function
namedtuple: function

class CSVStreamingReader(pyarrow.lib.RecordBatchReader):
    schema: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class CSVWriter(pyarrow.lib._CRecordBatchWriter):
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class ConvertOptions(pyarrow.lib._Weakrefable):
    __hash__: ClassVar[None] = ...  # type: ignore
    __slots__: ClassVar[tuple] = ...
    auto_dict_encode: Any
    auto_dict_max_cardinality: Any
    check_utf8: Any
    column_types: Any
    decimal_point: Any
    false_values: Any
    include_columns: Any
    include_missing_columns: Any
    null_values: Any
    quoted_strings_can_be_null: Any
    strings_can_be_null: Any
    timestamp_parsers: Any
    true_values: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def equals(self, ConvertOptionsother) -> Any: ...
    def validate(self) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce_cython__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __setstate_cython__(self, __pyx_state) -> Any: ...

class InvalidRow(_InvalidRow):
    __slots__: ClassVar[tuple] = ...

class ParseOptions(pyarrow.lib._Weakrefable):
    __hash__: ClassVar[None] = ...  # type: ignore
    __slots__: ClassVar[tuple] = ...
    delimiter: Any
    double_quote: Any
    escape_char: Any
    ignore_empty_lines: Any
    invalid_row_handler: Any
    newlines_in_values: Any
    quote_char: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def equals(self, ParseOptionsother) -> Any: ...
    def validate(self) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce_cython__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __setstate_cython__(self, __pyx_state) -> Any: ...

class ReadOptions(pyarrow.lib._Weakrefable):
    __hash__: ClassVar[None] = ...  # type: ignore
    __slots__: ClassVar[tuple] = ...
    autogenerate_column_names: Any
    block_size: Any
    column_names: Any
    encoding: Any
    skip_rows: Any
    skip_rows_after_names: Any
    use_threads: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def equals(self, ReadOptionsother) -> Any: ...
    def validate(self) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce_cython__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __setstate_cython__(self, __pyx_state) -> Any: ...

class SignalStopHandler:
    stop_token: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def _init_signals(self) -> Any: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, exc_type, exc_value, exc_tb) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class WriteOptions(pyarrow.lib._Weakrefable):
    __slots__: ClassVar[tuple] = ...
    batch_size: Any
    delimiter: Any
    include_header: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def validate(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class _ISO8601(pyarrow.lib._Weakrefable):
    __hash__: ClassVar[None] = ...  # type: ignore
    __slots__: ClassVar[tuple] = ...
    @classmethod
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class _InvalidRow(tuple):
    _asdict: ClassVar[function] = ...
    _field_defaults: ClassVar[dict] = ...
    _fields: ClassVar[tuple] = ...
    _replace: ClassVar[function] = ...
    __getnewargs__: ClassVar[function] = ...
    __match_args__: ClassVar[tuple] = ...
    __slots__: ClassVar[tuple] = ...
    actual_columns: Any
    expected_columns: Any
    number: Any
    text: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def _make(cls, *args, **kwargs) -> Any: ...

def __pyx_unpickle__ISO8601(__pyx_type, long__pyx_checksum, __pyx_state) -> Any: ...
def frombytes(*args, **kwargs) -> Any: ...
def open_csv(
    input_file,
    read_options=...,
    parse_options=...,
    convert_options=...,
    MemoryPoolmemory_pool=...,
) -> Any: ...
@overload
def read_csv(
    input_file,
    read_options=...,
    parse_options=...,
    convert_options=...,
    MemoryPoolmemory_pool=...,
) -> Any: ...
@overload
def read_csv(source) -> Any: ...
def tobytes(o) -> Any: ...
def write_csv(
    data, output_file, write_options=..., MemoryPoolmemory_pool=...
) -> Any: ...
